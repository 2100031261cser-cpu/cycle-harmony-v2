Admin login

Email: nany
Password: 123



Delivery boy login

Email: ram@123
Password: 123



================================================================================
CYCLE PHASE CHECKER LOGIC (Frontend Calculation)
File: src/lib/cycleCalculator.ts
================================================================================

interface CycleInput {
  last_period_date: string;
  today: string;
  average_cycle: number;
  name: string;
}

interface CycleResult {
  message: string;
  phase: string;
  price_total: number;
  weight: number;
  quantity: number;
  A: number;
  B: number;
  D: number;
  BB: number;
}

export function calculateCycleMessage(data: CycleInput): CycleResult {
  let lastPeriodDate = new Date(data.last_period_date);
  const today = new Date(data.today);
  const BB = data.average_cycle;

  // Day 1 = last_period_date
  let A = Math.floor((today.getTime() - lastPeriodDate.getTime()) / (1000 * 60 * 60 * 24)) + 1;

  if (A < 1) {
    throw new Error("Last period date cannot be in the future");
  }

  const B = Math.ceil(BB / 2);

  if (A > BB) {
    const cyclesPassed = Math.floor((A - 1) / BB);
    lastPeriodDate = new Date(lastPeriodDate.getTime() + cyclesPassed * BB * 24 * 60 * 60 * 1000);
    A = Math.floor((today.getTime() - lastPeriodDate.getTime()) / (1000 * 60 * 60 * 24)) + 1;
  }

  let phase: string;
  let D: number;

  if (A <= B) {
    phase = "Phase-1";
    D = B - A;
  } else {
    phase = "Phase-2";
    D = BB - A;
  }

  if (D < 0) {
    D = 0;
  }

  const midpointDate = new Date(lastPeriodDate.getTime() + (B - 1) * 24 * 60 * 60 * 1000);
  const phase2StartDate = new Date(midpointDate.getTime() + 24 * 60 * 60 * 1000);
  const cycleEndDate = new Date(lastPeriodDate.getTime() + (BB - 1) * 24 * 60 * 60 * 1000);
  const nextCycleDate = cycleEndDate;

  const ladduWeight = 30;
  const ladduRate = 0.866;

  // For pre-orders (D <= 8), use fixed values
  const isPreOrder = D <= 8;
  const priceTotal = isPreOrder ? 390 : Math.round(ladduWeight * ladduRate * D);
  const weight = isPreOrder ? 450 : D * ladduWeight+15;
  const quantity = isPreOrder ? 15 : D;

  let message: string;

  if (phase === "Phase-1") {
    if (D <= 8) {
      message = `Hi ${data.name} maâ€™am! ðŸŒ¸\n Today is Day ${A} of your menstrual cycle.\n You have only ${D+1} days left to complete Phase 1 (ends on ${midpointDate.toISOString().split('T')[0]}).\nPhase 2 laddus will start from ${phase2StartDate.toISOString().split('T')[0]}.\nPre-orders are now open â€” place your order today to reserve your Phase 2 laddus.\n ðŸ“¦ Delivery Date: ${midpointDate.toISOString().split('T')[0]}\n ðŸ“¦ Quantity: 15 laddus\n âš–ï¸ Weight: 450 g\n ðŸ’° Total Price:\n 30 g (per laddu) Ã— â‚¹0.866 (per g) Ã— 15 laddus = â‚¹390\n`;
    } else {
      message = `Hi ${data.name} maâ€™am! ðŸŒ¸\n Today is Day ${A} of your menstrual cycle.\n We will deliver ${D+1} Phase-1 laddus (Flax + Pumpkin).\n Quantity: ${quantity+1} laddus\n Weight: ${weight} g\n Total Price: 30 g (per laddu) Ã— â‚¹0.866 (per g) Ã— ${D + 1} laddus = â‚¹${priceTotal}`;
    }
  } else {
    if (D <= 8) {
      message = `Hi ${data.name} maâ€™am! ðŸŒ¸\n Today is Day ${A} of your menstrual cycle.\n You have only ${D} days left to complete Phase 2 (ends on ${cycleEndDate.toISOString().split('T')[0]}).\n Phase 1 laddus will start from ${nextCycleDate.toISOString().split('T')[0]}.\n Pre-orders are now open â€” place your order today to reserve your Phase 1 laddus.\n ðŸ“¦ Delivery Date: ${nextCycleDate.toISOString().split('T')[0]}\n ðŸ“¦ Quantity: 15 laddus\n âš–ï¸ Weight: 450 g\n ðŸ’° Total Price:30 g (per laddu) Ã— â‚¹0.866 (per g) Ã— 15 laddus = â‚¹390\n`;
    } else {
      message = `Hi ${data.name} maâ€™am! ðŸŒ¸\n Today is Day ${A} of your menstrual cycle.\n We'll deliver ${D} Phase-2 laddus (Sunflower + Sesame).\nQuantity = ${quantity} laddus\nWeight : ${weight} g\nTotal price = 30 g(per laddu) Ã— â‚¹0.866(per g) Ã— ${D}(laddus) = â‚¹${priceTotal}`;
    }
  }

  return {
    message,
    phase,
    price_total: priceTotal,
    weight,
    quantity,
    A,
    B,
    D,
    BB
  };
}


================================================================================
ORDER SUBMISSION LOGIC (Backend API)
File: server/routes/orderRoutes.js
================================================================================

// ... (imports omitted for brevity, see original file)

// Create a new order
router.post('/orders', async (req, res) => {
  try {
    const {
      fullName,
      phone,
      periodsStarted,
      cycleLength,
      phase,
      totalQuantity,
      totalWeight,
      totalPrice,
      address,
      paymentMethod,
      message,
      age // Extract age
    } = req.body;

    // Validate required fields
    if (!fullName || !phone || !periodsStarted || !cycleLength || !phase ||
      !totalQuantity || !totalWeight || !totalPrice || !address) {
      return res.status(400).json({
        success: false,
        message: 'Missing required fields'
      });
    }

    // Validate address fields
    if (!address.house || !address.area || !address.pincode) {
      return res.status(400).json({
        success: false,
        message: 'Missing required address fields (house, area, pincode)'
      });
    }

    // Link Customer & Generate IDs
    let customer = await mongoose.model('Customer').findOne({ phone });
    let currentCustomerId;

    if (customer) {
      // Customer exists
      if (!customer.customerId) {
        // Legacy customer (exists but no ID), generate one now
        customer.customerId = await generateCustomerId();
        await customer.save();
      }
      currentCustomerId = customer.customerId;

      // Update existing customer details
      customer.name = fullName;
      if (age) customer.age = age;

      // Add address if new
      // Simple check to avoid duplicates (optional improvement)
      customer.addresses.push({
        house: address.house,
        area: address.area,
        landmark: address.landmark || '',
        pincode: address.pincode,
        mapLink: address.mapLink || '',
        label: address.label || 'Home'
      });
      // We will push the order ID after saving the order
    } else {
      // Create new customer
      const newCustomerId = await generateCustomerId();
      currentCustomerId = newCustomerId;

      customer = new mongoose.model('Customer')({
        customerId: newCustomerId,
        phone,
        name: fullName,
        age: age || 0,
        addresses: [{
          house: address.house,
          area: address.area,
          landmark: address.landmark || '',
          pincode: address.pincode,
          mapLink: address.mapLink || '',
          label: address.label || 'Home'
        }],
        orders: [] // Will push later
      });
      await customer.save();
    }

    // Generate Order ID based on Customer ID
    const newOrderId = await generateOrderId(currentCustomerId);

    // Create new order
    const order = new Order({
      customerId: currentCustomerId,
      orderId: newOrderId,
      fullName,
      phone,
      periodsStarted: new Date(periodsStarted),
      cycleLength,
      phase,
      totalQuantity,
      totalWeight,
      totalPrice,
      address: {
        house: address.house,
        area: address.area,
        landmark: address.landmark || '',
        pincode: address.pincode,
        mapLink: address.mapLink || '',
        label: address.label || 'Home'
      },
      paymentMethod: paymentMethod || 'Cash on Delivery',
      message: message || '',
      orderStatus: 'Pending'
    });

    // Save to database
    const savedOrder = await order.save();

    // Link order to customer
    customer.orders.push(savedOrder._id);
    await customer.save();

    res.status(201).json({
      success: true,
      message: 'Order created successfully',
      data: savedOrder
    });

  } catch (error) {
    console.error('Error creating order:', error);
    res.status(500).json({
      success: false,
      message: 'Error creating order',
      error: error.message
    });
  }
});
